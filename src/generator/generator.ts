import * as fs from "fs"
import generateReact from "./generateReact"
export function generateProject({ name, entities, database, relations, includeReact }) {

    fs.opendir(`./${name}Project`, (err, dat) => {
        if (dat) {
            console.log(`A project already exists with the name ${name}Project`)
        } else {



            fs.mkdir(`${name}Project`, (dat) => {
                if (includeReact) {
                    generateReact({ name, entities, relations })
                }
            })

            fs.appendFile(`./${name}Project/tsconfig.json`,
                `
    {
        "compilerOptions": {
         "lib": [
            "es5",
            "es6"
            ],
        "target": "esnext",
        "module": "commonjs",
        "moduleResolution": "node",
        "outDir": "./build",
        "emitDecoratorMetadata": true,
        "experimentalDecorators": true,
        "sourceMap": true,
        }
    }
    `, () => { });

            fs.appendFile(`./${name}Project/README.md`,
                `
## ${name}Project
#### Generated by https://github.com/OdidaProtas/ProGenerator

##### Generated Models 

${entities.map((e: any) => {
                    return `
#### ${e.EntityName}

##### Columns

Field \` id  \`:  \` string  \`- \` uuid  \`

${e.columns.map((c: any) => `Field  \` ${c.key}\` : \`${c.type}\``).join("\n")}

    `
                }).join("\n\n")}


##### Relations

${relations.map((r: any) => `Relation \`  ${r.type} \` - \`left: ${r.left} \`,  \`right: ${r.right} \`  `)}

## Routes

${entities.map((e: any) => {
                    const n = e.EntityName
                    return `
    \`post - /${n} \` saves and returns one or array of ${n}

    \`get - /${n} \` returns all ${n}s. optional take and skip query params ie. ?take=10&skip=20 . Includes relations by default
    
    \`get  - /${n}/:id \` returns one ${n} with matching id. Includes relations by default

    \`put  - /${n} \` updates and returns one or array of ${n}  

    \`delete /${n}/:id \` deletes ${n} of given id
    `
                })}
                `, () => { })

            fs.appendFile(`./${name}Project/package.json`,
                `
    {
        "name": "${name}Project",
        "version": "0.0.1",
        "description": "Created with https://github.com/OdidaProtas/ProGenerator",
        "devDependencies": {
            "@types/bcrypt": "^5.0.0",
            "@types/body-parser": "^1.19.1",
            "@types/cors": "^2.8.12",
            "@types/express": "^4.17.13",
            "@types/jsonwebtoken": "^8.5.5",
            "@types/node": "^16.11.4",
            "@types/nodemailer": "^6.4.4",
            "nodemon": "^2.0.14",
            "typescript": "^4.3.5",
            "ts-node": "^10.1.0"
        },
        "dependencies": {
            "bcrypt": "^5.0.1",
            "body-parser": "^1.19.0",
            "cors": "^2.8.5",
            "dotenv": "^10.0.0",
            "express": "^4.17.1",
            "pg": "^8.7.1",
            "reflect-metadata": "^0.1.13",
            "typeorm": "^0.2.36"
        },
        "scripts": {
            "start": "node build/index.js",
            "start-dev": "ts-node src/index.ts",
            "dev": "nodemon",
            "typeorm": "node --require ts-node/register ./node_modules/typeorm/cli.js",
            "build": "tsc",
            "mm": "npm run typeorm migration:generate -- -n ${name}",
            "mg": "npm run typeorm migration:run",
            "build-prod": "cd client && npm install && npm run build && cd .. && npm install && npm run build"
        }
    }
    `,
                () => { })

            fs.appendFile(`./${name}Project/nodemon.json`,
                `
    {
        "watch": ["src"],
        "ext": ".ts",
        "ignore": [],
        "exec": "ts-node ./src/index.ts"
    }
    `, () => { })

            fs.appendFile(`./${name}Project/.gitignore`,
                `
    .idea/
    .vscode/
    node_modules/
    tmp/
    temp/
    .env`, () => { })

            fs.appendFile(`./${name}Project/.env`,
                `
    PORT=7072
    ENVIRONMENT=debug
    SECRET=xzqp+k7gCzM*hK3]JCR6$Ha{SsO(u]_[{!vl$&oV?*H:J<h[zC2j:Gxm<C)S*Ct
    DATABASE_URL=postgres://"database_name":"database_password"@localhost:5432/${name}_database
        `, () => { })

            fs.appendFile(`./${name}Project/ormconfig.js`,
                `
    const environment = process.env.ENVIRONMENT;
    const ext = environment === "debug" ? "ts" : "js";
    const app = environment === "debug" ? "src" : "build";
    
    module.exports = {
        type: "postgres",
        port: 5432,
        url: process.env.DATABASE,
        logging: false,
        entities: [\`\${ app }/entity/**/*.\${ext}\`],
        migrations: [\`\${ app }/migration/**/*.\${ ext }\`],
        subscribers: [\`\$ { app }/subscriber/**/*.\${ext}\`],
        cli: { entitiesDir:\`\${ app }/entity\`,
        migrationsDir: \`\${ app }/migration\`,
        subscribersDir: \`\${ app }/subscriber\`},
        ssl: false
        // extra: {
        // ssl: {
        //     rejectUnauthorized: false,
         //   },
        // },
         }
                `, () => { })

            fs.mkdir(`./${name}Project/src`, () => {
                fs.appendFile(`./${name}Project/src/index.ts`, `
    import "reflect-metadata";
    import * as dotenv from "dotenv";
    
    import ${name}App from "./${name.toLowerCase()}/${name.toLowerCase()}";
    import MiddleWare from "./middleware/Middleware";
    
    import { Routes } from "./routes";
    
    dotenv.config();
    
    ${name}App.run({
        routes: Routes,
        middleware: new MiddleWare().apply(),
        port: process.env.PORT,
    });
    
    `, () => { })
            })

            fs.mkdir(`./${name}Project/src/${name.toLowerCase()}`, () => { })
            fs.mkdir(`./${name}Project/src/entity`, () => { })
            fs.mkdir(`./${name}Project/src/migration`, () => { })

            fs.mkdir(`./${name}Project/src/middleware`, () => {
                fs.appendFile(`./${name}Project/src/middleware/Middleware.ts`, `
                        import { NextFunction, Request, Response } from "express";
    
    import * as cors from "cors";
    import * as bodyParser from "body-parser";
    
    export default class MiddleWare {
        
    
      apply() {
        return [
          bodyParser.json(),
          cors("*" as any),
        ]
      }
        
      async pass(request: Request, response: Response, next: NextFunction) {
        next();
      }
    }
    `, () => { })
            })


            fs.mkdir(`./${name}Project/src/helpers`, () => {

                fs.appendFile(`./${name}Project/src/helpers/createRoute.ts`, `
    export default function createRoute(
        m: string,
        r: string,
        c: any,
        a: string,
        p ? : any
    ) {
        return {
            method: m,
            route: r,
            controller: c,
            action: a,
            perimissions: p,
            isAuthenticated: false
        };
    }`, () => { })

                fs.appendFile(`./${name}Project/src/helpers/registerRoutes.ts`, `
    export default function(routesArray: any[]) {
        return routesArray.reduce((p, c) => p.concat(c), [])
    }`, () => { })

                fs.appendFile(`./${name}Project/src/helpers/useTryCatch.ts`, `
    export default async function useTryCatch(promise: Promise < any > ) {
        try {
            return [await promise, null];
        } catch (e) {
            return [null, e];
        }
    }
    `, () => { })

                    , () => { }
            })


            entities.forEach(({ EntityName, columns }) => {

                const myRels = relations.filter((f: any) => f.right === EntityName || f.left === EntityName).filter((f: any, i: any, s: any) => s.indexOf(f) === i)
                function inverseRel({ type, left, right }) {

                    if (EntityName === left) {
                        return type;
                    } else {
                        const dir = ({
                            OneToOne: "OneToOne",
                            ManyToOne: "OneToMany",
                            OneToMany: "ManyToOne",
                            ManyToMany: "ManyToMany"
                        })
                        return dir[type]
                    }

                }

                function inverseType(type: string) {
                    if (type === "OneToMany" || type === "ManyToMany") {
                        return "[]"
                    }
                    return ""
                }

                fs.appendFile(`./${name}Project/src/entity/${EntityName}.ts`,
                    `
import { Request, Response, NextFunction } from "express"
import createRoute from "../helpers/createRoute";
import useTryCatch from "../helpers/useTryCatch";
import { PrimaryGeneratedColumn, Entity, Column, getRepository ${myRels.map((p: any) => `,${inverseRel(p)}`).filter((v, i, s) => s.indexOf(v) === i).map(p => p === ",OneToOne" ? ",OneToOne,JoinColumn" : p).join("")}} from "typeorm"
${myRels.map((m: any) => `import ${m.right === EntityName ? `${m.left}` : `${m.right}`} from "./${m.right === EntityName ? `${m.left}` : `${m.right}`}";`).join(``)}

@Entity() 
export default class ${EntityName} {
@PrimaryGeneratedColumn("uuid")
id: string

${columns.map((c: any) => `@Column(${c.nullable ? ` { nullable: true },` : ""}${c.default ? ` { default: ${c.default} },` : ""}) 
${c.key}: ${c.type}`).join("\n")}

${myRels.map((m: any) => `@${inverseRel(m)}(() => ${m.right === EntityName ? m.left : m.right}, ${(m.right === EntityName ? m.left : m.right).toLowerCase()} => ${(m.right === EntityName ? m.left : m.right).toLowerCase()}.${(m.right === EntityName ? m.right : m.left).toLowerCase()})
${m.type === "OneToOne" && m.left === EntityName ? "@JoinColumn()" : ""}
${(m.right === EntityName ? m.left : m.right).toLowerCase()}: ${m.right === EntityName ? m.left : m.right}${inverseType(inverseRel(m))}`).join("\n")} 
}

class ${EntityName}Controller {
    private ${EntityName[0]?.toLowerCase()}R = getRepository(${EntityName});

    async save(req: Request, res: Response, next: NextFunction) {
        const [data, error] = await useTryCatch(this.${EntityName[0].toLowerCase()}R.save(req.body));
        if (data) return data;
        else res.status(403).json(error);
    }

    async one(req: Request, res: Response, next: NextFunction) {
        const [data, error] = await useTryCatch(this.${EntityName[0].toLowerCase()}R.findOne())
    if (data) return data;
    else res.status(403).json(error);
}

async all(req: Request, res: Response, next: NextFunction) {
    if (Boolean(req.query.take) && Boolean(req.query.skip){
        const [data, error] = await useTryCatch(this.${EntityName[0].toLowerCase()}R.find())
        if (data) return data;
        else res.status(403).json(error);
} else {
    const [data, error] = await useTryCatch(this.uR.find())
    if (data) return data;
    else res.status(403).json(error);

  
}

async update(req: Request, res: Response, next: NextFunction) {
    const [data, error] = await useTryCatch(this.${EntityName[0].toLowerCase()}R.save(req.body))
    if (data) return data;
    else res.status(403).json(error);
}

async delete(req: Request, res: Response, next: NextFunction) {
    const [${EntityName.toLowerCase()}, error] = await useTryCatch(this.${EntityName[0].toLowerCase()}R.findOne(req.params.id))
    const [data, err] = await useTryCatch(this.${EntityName[0].toLowerCase()}R.remove(${EntityName.toLowerCase()}))
    if (data) return data;
    else res.status(403).json(error)
}

}


export const ${EntityName}Routes = [
createRoute("post", ${'"'}/${EntityName}${'"'}, ${EntityName}Controller, "save"),
createRoute("get", ${'"'}/${EntityName}${'"'}, ${EntityName}Controller, "all"),
createRoute("get", ${'"'}/${EntityName}/:id${'"'}, ${EntityName}Controller, "one"),
createRoute("put", ${'"'}/${EntityName}${'"'}, ${EntityName}Controller, "update"),
createRoute("delete", ${'"'}/${EntityName}/:id${'"'}, ${EntityName}Controller, "delete"),
]
`,
                    (err) => {
                        console.log(err || `\n\nCreate file ${EntityName} Model "../entity/${EntityName}.ts"`)
                    })
            })


            fs.appendFile(`./${name}Project/src/${name.toLowerCase()}/${name.toLowerCase()}.ts`, `
    import { createConnection } from "typeorm";
    import { Request, Response } from "express";
    
    import * as express from "express";
    
    export default class ${name}App {
    
    static run({ routes, admin, docs, middleware, port }: any): void {
        createConnection()
         .then(async(connection) => {
             const app = express();
             const http = require("http");
             const server = http.createServer(app)
             middleware.forEach((middleWare: any) => {
                 app.use((req, res, next) => middleWare(req, res, next, { server, app }))
            })
            routes.concat(admin || []).concat(docs || []).forEach((route: any) => {
                (app as any)[route.method](
                    route.route,
                    (req: Request, res: Response, next: Function) => {
                        const result = new(route.controller as any)()[route.action](
                    req,
                    res,
                    next
                );
                if (result instanceof Promise) {
                    result.then((result) =>
                       result !== null && result !== undefined ?
                        route.view ? res.sendFile(route.view) : res.send(result) :
                        undefined
                    );
                } else if (result !== null && result !== undefined) {
                    if (route.view) {
                        res.sendFile(route.view);
                                            } else {
                        res.json(result)
                       }
                   }
                    }
                );
            });
    
             app.get("/", (req, res) => {
                 res.json("index.html");
            });
    
            server.listen(port);
    
             console.log("Server has started on port: " + process.env.PORT);
         })
          .catch((error) => console.log(error));}}
    `, (err) => {

            })


            fs.appendFile(`./${name}Project/src/routes.ts`, `

${entities.map((e: any) => `
import { ${e.EntityName}Routes } from "./entity/${e.EntityName}";
`).join("\n")}

import registerRoutes from "./helpers/registerRoutes";


export const Routes = registerRoutes(
  [
      ${entities.map((e: any) => `${e.EntityName}Routes`)}
  ]
)
`, data => { })
        }

    })
}
